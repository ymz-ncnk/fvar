package fvar

import (
	"bytes"
	"go/format"
	"os"
	template_mod "text/template"
)

const template = "" +
	"// Code generated by fvar. DO NOT EDIT." +
	"\n\n" +
	"{{ $name := .Name }}" +
	"package {{.Package}}\n\n" +
	"var {{$name}} map[string]string\n" +
	"func init() {\n" +
	"	 {{$name}} = make(map[string]string)\n" +
	"  {{- range $fileName, $fileData := .Map }}\n" +
	"    {{$name}}[\"{{$fileName}}\"] = `{{$fileData}}`\n" +
	"  {{- end }}\n" +
	"}"

// Fvar generates a map variable initialized with the contents of the folder.
type Fvar struct{}

// Generate generates Golang source code that initializes the map variable with
// the contents of the folder - each key in the map is a file name, and the
// value is the file data.
func (v Fvar) Generate(conf Conf) (bs []byte, err error) {
	m, err := v.makeMap(conf.Folder)
	if err != nil {
		return
	}
	return v.generate(conf, m)
}

func (v Fvar) generate(conf Conf, m map[string]string) ([]byte, error) {
	tmpl, err := template_mod.New("base").Parse(template)
	if err != nil {
		return nil, err
	}
	buf := bytes.NewBuffer(make([]byte, 0))
	err = tmpl.ExecuteTemplate(buf, "base", struct {
		Package string
		Name    string
		Map     map[string]string
	}{
		Package: conf.Package,
		Name:    conf.VarName,
		Map:     m,
	})
	if err != nil {
		return nil, err
	}
	return format.Source(buf.Bytes())
}

func (v Fvar) makeMap(folder string) (map[string]string, error) {
	var (
		data     []byte
		filename string
		m        = make(map[string]string)
	)
	entries, err := os.ReadDir(folder)
	if err != nil {
		return nil, err
	}
	for i := 0; i < len(entries); i++ {
		if entries[i].IsDir() {
			return nil, ErrSubfolder
		}
		filename = entries[i].Name()
		data, err = os.ReadFile(folder + string(os.PathSeparator) + filename)
		if err != nil {
			return nil, err
		}
		m[string(filename)] = string(data)
	}
	return m, nil
}
